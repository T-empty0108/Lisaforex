<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>XAU/USD â€” OANDA + LISA FOREX</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700;800&family=Plus+Jakarta+Sans:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{font-family:'Plus Jakarta Sans',sans-serif;background:#000;color:#e2e8f0;height:100vh;overflow:hidden}
        .app{display:flex;flex-direction:column;height:100vh;padding:10px 14px;gap:8px}
        .top-bar{display:flex;justify-content:space-between;align-items:center;padding:10px 20px;background:linear-gradient(135deg,#080810,#0a0a14);border:1px solid #1a1a2e;border-radius:14px;flex-shrink:0}
        .top-left{display:flex;align-items:center;gap:16px}
        .pair-name{font-size:22px;font-weight:800;background:linear-gradient(135deg,#fbbf24,#f59e0b);-webkit-background-clip:text;-webkit-text-fill-color:transparent;letter-spacing:1px}
        .source-tag{font-size:10px;font-weight:700;color:#fbbf24;background:rgba(251,191,36,.1);border:1px solid rgba(251,191,36,.3);padding:2px 8px;border-radius:6px}
        .indicator-tag{font-size:10px;font-weight:700;color:#a78bfa;background:rgba(167,139,250,.1);border:1px solid rgba(167,139,250,.3);padding:2px 8px;border-radius:6px}
        .live-price{font-family:'JetBrains Mono',monospace;font-size:28px;font-weight:700;color:#fff;transition:color .3s}
        .live-price.up{color:#089981}.live-price.down{color:#f23645}
        .price-change{font-family:'JetBrains Mono',monospace;font-size:14px;font-weight:600;padding:4px 10px;border-radius:8px}
        .price-change.up{background:rgba(8,153,129,.15);color:#089981}.price-change.down{background:rgba(242,54,69,.15);color:#f23645}
        .top-right{display:flex;align-items:center;gap:14px}
        .status-dot-live{width:10px;height:10px;border-radius:50%;background:#089981;animation:pd 2s infinite}
        .status-dot-live.error{background:#f23645}.status-dot-live.loading{background:#fbbf24}
        @keyframes pd{0%,100%{opacity:1}50%{opacity:.3}}
        .status-info{display:flex;flex-direction:column;align-items:flex-end;gap:2px}
        .status-text{font-size:12px;color:#64748b;font-weight:600}
        .status-text span{font-family:'JetBrains Mono',monospace;color:#94a3b8}
        .tf-buttons{display:flex;gap:4px}
        .tf-btn{padding:5px 10px;border-radius:8px;font-size:12px;font-weight:700;border:1px solid #1a1a2e;background:transparent;color:#64748b;cursor:pointer;transition:all .2s;font-family:'JetBrains Mono',monospace}
        .tf-btn:hover{border-color:#fbbf24;color:#fbbf24}
        .tf-btn.active{background:rgba(251,191,36,.15);border-color:#fbbf24;color:#fbbf24}
        .chart-wrapper{flex:1;border-radius:14px;overflow:hidden;border:1px solid #1a1a2e;background:#000;position:relative;min-height:0}
        #chart{width:100%;height:100%}
        .watermark{position:absolute;bottom:50px;left:50%;transform:translateX(-50%);font-size:52px;font-weight:800;color:rgba(255,255,255,.02);letter-spacing:8px;z-index:5;pointer-events:none}
        .stats-bar{display:flex;gap:8px;padding:8px 16px;background:linear-gradient(135deg,#080810,#0a0a14);border:1px solid #1a1a2e;border-radius:14px;flex-shrink:0}
        .stat-item{flex:1;padding:8px 12px;text-align:center;background:rgba(0,0,0,.5);border-radius:10px;border:1px solid #1a1a2e}
        .stat-label{font-size:11px;font-weight:700;color:#64748b;text-transform:uppercase;letter-spacing:1.5px;margin-bottom:4px}
        .stat-value{font-family:'JetBrains Mono',monospace;font-size:16px;font-weight:700;color:#fff}
        .stat-value.up{color:#089981}.stat-value.down{color:#f23645}
        .overlay-msg{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:15px;color:#94a3b8;font-weight:600;background:rgba(0,0,0,.92);padding:20px 30px;border-radius:12px;border:1px solid #1a1a2e;z-index:20;text-align:center;line-height:1.6}
        .overlay-msg.hidden{display:none}
        .overlay-msg .spinner{display:inline-block;width:18px;height:18px;border:2px solid #1a1a2e;border-top:2px solid #fbbf24;border-radius:50%;animation:spin .8s linear infinite;vertical-align:middle;margin-right:8px}
        @keyframes spin{to{transform:rotate(360deg)}}
        .countdown-label{position:absolute;z-index:16;font-family:'JetBrains Mono',monospace;font-size:11px;font-weight:500;color:#fff;padding:2px 20px 2px 14px;pointer-events:none;opacity:0;transition:opacity .15s;white-space:nowrap;text-align:center}
        .countdown-label.visible{opacity:1}
        .signal-label{position:absolute;z-index:15;pointer-events:none;display:flex;align-items:center;gap:6px;font-family:'JetBrains Mono',monospace;font-size:11px;font-weight:700;white-space:nowrap;opacity:0;transition:opacity .2s}
        .signal-label.visible{opacity:1}
        .signal-label .sig-text{color:#fbbf24;background:rgba(251,191,36,.15);border:1px solid rgba(251,191,36,.4);padding:2px 8px;border-radius:4px}
        .signal-label .sig-status{padding:2px 8px;border-radius:4px;font-weight:800;text-transform:uppercase}
        .signal-label .sig-status.waiting{color:#60a5fa;background:rgba(59,130,246,.2);border:1px solid rgba(59,130,246,.4);animation:sigBlink 1s infinite}
        .signal-label .sig-status.running{color:#fcd34d;background:rgba(251,191,36,.2);border:1px solid rgba(251,191,36,.4);animation:sigBlink 1s infinite}
        .signal-label .sig-status.tp{color:#4ade80;background:rgba(34,197,94,.2);border:1px solid rgba(34,197,94,.4)}
        .signal-label .sig-status.sl{color:#f87171;background:rgba(239,68,68,.2);border:1px solid rgba(239,68,68,.4)}
        @keyframes sigBlink{0%,100%{opacity:1}50%{opacity:.3}}
        .scroll-mode-btns{position:absolute;bottom:12px;right:12px;z-index:16;display:flex;gap:4px}
        .scroll-mode-btn{width:32px;height:32px;border-radius:8px;font-family:'JetBrains Mono',monospace;font-size:14px;font-weight:800;border:1px solid #1a1a2e;background:rgba(0,0,0,.7);color:#555;cursor:pointer;transition:all .2s;display:flex;align-items:center;justify-content:center}
        .scroll-mode-btn:hover{border-color:#fbbf24;color:#fbbf24}
        .scroll-mode-btn.active{background:rgba(251,191,36,.15);border-color:#fbbf24;color:#fbbf24}
    </style>
</head>
<body>
<div class="app">
    <div class="top-bar">
        <div class="top-left">
            <div class="pair-name">âšœ XAU / USD</div>
            <div class="source-tag">OANDA</div>
            <div class="indicator-tag">LISA FOREX</div>
            <div class="live-price" id="livePrice">Connecting...</div>
            <div class="price-change up" id="priceChange">--</div>
        </div>
        <div class="top-right">
            <div class="tf-buttons">
                <button class="tf-btn active" data-tf="1">1m</button>
                <button class="tf-btn" data-tf="5">5m</button>
                <button class="tf-btn" data-tf="15">15m</button>
                <button class="tf-btn" data-tf="60">1h</button>
            </div>
            <div class="status-dot-live loading" id="statusDot"></div>
            <div class="status-info">
                <div class="status-text">Ticks: <span id="tickCount">0</span></div>
                <div class="status-text">Updated: <span id="updateTime">--:--:--</span></div>
            </div>
        </div>
    </div>
    <div class="chart-wrapper">
        <div id="chart"></div>
        <div class="watermark">XAU/USD</div>
        <div class="overlay-msg" id="overlay"><span class="spinner"></span> Äang káº¿t ná»‘i...</div>
        <!-- VIDYA legend and Vol Delta removed -->
        <div class="countdown-label" id="countdown"></div>
        <div class="signal-label" id="signalLabel"><span class="sig-text" id="sigText"></span><span class="sig-status" id="sigStatus"></span></div>
        <div class="scroll-mode-btns">
            <button class="scroll-mode-btn active" id="btnA" title="Auto scroll">A</button>
            <button class="scroll-mode-btn" id="btnP" title="Elastic pin">P</button>
        </div>
    </div>
    <div class="stats-bar">
        <div class="stat-item"><div class="stat-label">24h Open</div><div class="stat-value" id="statOpen">---</div></div>
        <div class="stat-item"><div class="stat-label">24h High</div><div class="stat-value up" id="statHigh">---</div></div>
        <div class="stat-item"><div class="stat-label">24h Low</div><div class="stat-value down" id="statLow">---</div></div>
        <div class="stat-item"><div class="stat-label">24h Range</div><div class="stat-value" id="statSpread">---</div></div>
        <div class="stat-item"><div class="stat-label">Latency</div><div class="stat-value" id="statLatency">---</div></div>
        <div class="stat-item"><div class="stat-label">Candles</div><div class="stat-value" id="statCandles">---</div></div>
    </div>
</div>

<script src="https://unpkg.com/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>
<script>
(()=>{
    const SERVER = window.location.origin;
    const WS_URL = SERVER.replace("http","ws");
    const HIST_BARS = {"1":1500,"5":500,"15":300,"60":200};
    const INT_SEC = {"1":60,"5":300,"15":900,"60":3600};
    const BG = '#000000';

    // Colors
    const C_UP = '#089981', C_DN = '#f23645';
    const C_VUP = '#17d6a6', C_VDN = '#d33066';

    // State
    let curTF = "1", curSec = 60;
    let hist = [], liveC = null, ticks = 0;
    let sHi = 0, sLo = Infinity, sOpen = null, prevP = null;
    let lastHT = 0, ready = false, ws = null;
    let extra = [], cSeries = null, saved = null;
    let scrollM = 'auto';

    // Store VIDYA line series per segment for markers
    let vidyaLineSeries = [];

    const chartEl = document.getElementById('chart');
    const chart = LightweightCharts.createChart(chartEl, {
        layout: { background: { type:'solid', color:BG }, textColor:'#9a9ab0', fontFamily:"'JetBrains Mono',monospace", fontSize:12 },
        grid: { vertLines:{ color:'rgba(255,255,255,0.04)' }, horzLines:{ color:'rgba(255,255,255,0.04)' } },
        crosshair: {
            mode: LightweightCharts.CrosshairMode.Normal,
            vertLine: { color:'rgba(251,191,36,0.3)', width:1, style:2, labelBackgroundColor:'#1a1a2e' },
            horzLine: { color:'rgba(251,191,36,0.3)', width:1, style:2, labelBackgroundColor:'#1a1a2e' },
        },
        rightPriceScale: { borderColor:'#1a1a2e', scaleMargins:{ top:0.15, bottom:0.15 }, autoScale:true },
        timeScale: { borderColor:'#1a1a2e', timeVisible:true, secondsVisible:false, barSpacing:6, rightOffset:15 },
        localization: { timeFormatter: t => new Date(t*1000).toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit',timeZone:'UTC'}) },
    });

    // cSeries created dynamically in loadHist â€” added AFTER indicator layers so candles render on top

    function clrExtra() {
        for (const s of extra) { try { chart.removeSeries(s); } catch(e) {} }
        extra = [];
        vidyaLineSeries = [];
        // Remove old candle series so it can be re-added on top after indicators
        if (cSeries) { try { chart.removeSeries(cSeries); } catch(e) {} cSeries = null; }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SCROLL: Auto / Pin (5-min interval)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let pinTimer = null;

    function setScroll(m) {
        scrollM = m;
        document.getElementById('btnA').classList.toggle('active', m === 'auto');
        document.getElementById('btnP').classList.toggle('active', m === 'pin');
        if (pinTimer) { clearInterval(pinTimer); pinTimer = null; }
        if (m === 'auto') {
            chart.timeScale().scrollToRealTime();
        } else {
            // Pin mode: scroll to realtime every 5 minutes
            pinTimer = setInterval(() => {
                chart.timeScale().scrollToRealTime();
            }, 5 * 60 * 1000);
        }
    }
    document.getElementById('btnA').addEventListener('click', () => setScroll('auto'));
    document.getElementById('btnP').addEventListener('click', () => setScroll('pin'));

    function smartScroll() {
        if (scrollM === 'auto') { chart.timeScale().scrollToRealTime(); return; }
        // Pin mode: do nothing â€” timer handles it every 5 minutes
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SESSION SEPARATORS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function renderSessions() {
        if (!hist.length) return;
        const iSec = INT_SEC[curTF];
        if (iSec > 900) return;
        const first = hist[0].time, last = hist[hist.length-1].time;
        const ds = Math.floor(first / 86400) * 86400;
        const de = Math.floor(last / 86400) * 86400 + 86400;
        const defs = [
            { name:'ASIA', h:0, lc:'rgba(255,200,50,0.15)', tc:'rgba(255,200,50,0.5)' },
            { name:'LONDON', h:8, lc:'rgba(50,150,255,0.15)', tc:'rgba(50,150,255,0.5)' },
            { name:'NEW YORK', h:13, lc:'rgba(255,80,120,0.15)', tc:'rgba(255,80,120,0.5)' },
        ];
        for (let day = ds; day <= de; day += 86400) {
            for (const d of defs) {
                const t = day + d.h * 3600;
                if (t < first - iSec * 5 || t > last + iSec * 5) continue;
                const sn = Math.round(t / iSec) * iSec;
                const ls = chart.addLineSeries({
                    color: d.lc, lineWidth:1, lineStyle:2,
                    lastValueVisible:false, priceLineVisible:false, crosshairMarkerVisible:false,
                });
                ls.setData([{ time:sn, value:0 }]);
                ls.setMarkers([{ time:sn, position:'aboveBar', color:d.tc, shape:'square', text:d.name, size:0 }]);
                extra.push(ls);
            }
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // LOAD HISTORY
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async function loadHist(tf) {
        const ov = document.getElementById('overlay');
        ov.innerHTML = `<span class="spinner"></span> Äang táº£i OANDA (${tf}m) + LISA FOREX...`;
        ov.classList.remove('hidden');
        try {
            const resp = await fetch(`${SERVER}/api/history?interval=${tf}&bars=${HIST_BARS[tf]||500}`);
            const data = await resp.json();
            if (data.error) { ov.innerHTML = `âš ï¸ ${data.error}`; setTimeout(() => ov.classList.add('hidden'), 3000); return; }
            hist = data.candles || [];
            lastHT = hist.length ? hist[hist.length-1].time : 0;
            calcS();
            clrExtra();

            renderSessions();
            if (data.indicator) { saved = data.indicator; renderVIDYA(data.indicator); }

            // Create candle series LAST â€” renders on top of all indicator layers
            cSeries = chart.addCandlestickSeries({
                upColor:C_UP, downColor:C_DN, borderUpColor:C_UP, borderDownColor:C_DN,
                wickUpColor:C_UP, wickDownColor:C_DN,
                lastValueVisible: true,
                priceLineVisible: true,
                priceLineWidth: 1,
                priceLineStyle: LightweightCharts.LineStyle.Dotted,
                priceLineColor: '#089981',
            });
            renderAll(true);

            ov.classList.add('hidden');
            console.log(`âœ… ${hist.length} candles | VIDYA: ${data.indicator?.vidya_line?.length||0}`);
        } catch(e) {
            console.error("Load:", e);
            ov.innerHTML = 'âš ï¸ KhÃ´ng káº¿t ná»‘i Ä‘Æ°á»£c server';
            setTimeout(() => ov.classList.add('hidden'), 3000);
        }
    }

    function calcS() {
        sOpen = null; sHi = 0; sLo = Infinity;
        for (const c of hist) {
            if (!sOpen) sOpen = c.open;
            if (c.high > sHi) sHi = c.high;
            if (c.low < sLo) sLo = c.low;
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // VIDYA FILL â€” Neon glow at VIDYA line, fading to transparent at candles
    //
    // Lightweight Charts area: topColor at line â†’ bottomColor at chart bottom
    //
    // UPTREND (vidya below candles):
    //   1. Gradient area from HL2 line:
    //      topColor = transparent (at hl2/candle level)
    //      bottomColor = bright neon (going down toward vidya)
    //      â†’ Creates: transparent near candles â†’ bright near vidya âœ“
    //   2. Clip mask from VIDYA line:
    //      Solid background color â†’ hides everything below vidya
    //      (invisible because it matches the #000 background)
    //
    // DOWNTREND (vidya above candles):
    //   1. Gradient area from VIDYA line:
    //      topColor = bright neon (at vidya level)
    //      bottomColor = transparent (going down toward hl2)
    //      â†’ Creates: bright at vidya â†’ transparent near candles âœ“
    //   2. Clip mask from HL2 line:
    //      Solid background color â†’ hides everything below hl2
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function renderVIDYA(ind) {
        if (!ind?.vidya_line?.length) return;

        const hl2M = {};
        for (const c of hist) hl2M[c.time] = r3((c.high + c.low) / 2);

        // Build segments by trend
        const segs = [];
        let s = { tr: ind.vidya_line[0].trend, pts: [ind.vidya_line[0]] };
        for (let i = 1; i < ind.vidya_line.length; i++) {
            const p = ind.vidya_line[i];
            if (p.trend !== s.tr) { segs.push(s); s = { tr: p.trend, pts: [p] }; }
            else s.pts.push(p);
        }
        segs.push(s);

        vidyaLineSeries = [];

        for (let si = 0; si < segs.length; si++) {
            const seg = segs[si];
            if (seg.pts.length < 2) continue;
            const up = seg.tr === "up";
            const isLast = (si === segs.length - 1);

            // Prepare data arrays
            const vD = [], hD = [];
            for (const p of seg.pts) {
                const h = hl2M[p.time];
                if (h === undefined) continue;
                vD.push({ time: p.time, value: p.value });
                hD.push({ time: p.time, value: h });
            }
            if (vD.length < 2) continue;

            // â”€â”€ Neon glow fill: bright at VIDYA, transparent at candles â”€â”€

            if (up) {
                // UPTREND: vidya is below, hl2 is above
                // Gradient from HL2: transparent at top â†’ bright neon going down
                const gradientFill = chart.addAreaSeries({
                    topColor: 'rgba(23,214,166,0.0)',       // transparent at hl2 (candle level)
                    bottomColor: 'rgba(23,214,166,0.45)',    // bright neon going down toward vidya
                    lineColor: 'transparent', lineWidth: 0,
                    lastValueVisible: false, priceLineVisible: false, crosshairMarkerVisible: false,
                });
                gradientFill.setData(hD);
                extra.push(gradientFill);

                // Clip mask from VIDYA: solid BG to hide fill below vidya line
                // This is invisible because it matches the chart background (#000)
                const clipMask = chart.addAreaSeries({
                    topColor: BG, bottomColor: BG,
                    lineColor: 'transparent', lineWidth: 0,
                    lastValueVisible: false, priceLineVisible: false, crosshairMarkerVisible: false,
                });
                clipMask.setData(vD);
                extra.push(clipMask);

            } else {
                // DOWNTREND: vidya is above, hl2 is below
                // Gradient from VIDYA: bright neon at top â†’ transparent going down
                const gradientFill = chart.addAreaSeries({
                    topColor: 'rgba(211,48,102,0.45)',       // bright neon at vidya line
                    bottomColor: 'rgba(211,48,102,0.0)',     // transparent going down toward candles
                    lineColor: 'transparent', lineWidth: 0,
                    lastValueVisible: false, priceLineVisible: false, crosshairMarkerVisible: false,
                });
                gradientFill.setData(vD);
                extra.push(gradientFill);

                // Clip mask from HL2: solid BG to hide fill below hl2 line
                const clipMask = chart.addAreaSeries({
                    topColor: BG, bottomColor: BG,
                    lineColor: 'transparent', lineWidth: 0,
                    lastValueVisible: false, priceLineVisible: false, crosshairMarkerVisible: false,
                });
                clipMask.setData(hD);
                extra.push(clipMask);
            }

            // â”€â”€ VIDYA line (drawn on top of fill) â”€â”€
            const ln = chart.addLineSeries({
                color: up ? C_VUP : C_VDN, lineWidth: 2,
                lastValueVisible: false, priceLineVisible: false, crosshairMarkerVisible: false,
            });
            ln.setData(vD);
            extra.push(ln);

            // â”€â”€ Markers on the VIDYA line series â”€â”€
            const markers = [];

            // â–²/â–¼ at start of segment
            markers.push({
                time: vD[0].time,
                position: up ? 'belowBar' : 'aboveBar',
                color: up ? C_VUP : C_VDN,
                shape: up ? 'arrowUp' : 'arrowDown',
                text: '', size: 1,
            });

            // âœª at end â€” only for the last (active) segment
            if (isLast && vD.length > 1) {
                markers.push({
                    time: vD[vD.length - 1].time,
                    position: up ? 'belowBar' : 'aboveBar',
                    color: up ? C_VUP : C_VDN,
                    shape: 'circle', text: '', size: 0,
                });
            }

            markers.sort((a, b) => a.time - b.time);
            ln.setMarkers(markers);

            vidyaLineSeries.push({
                series: ln, trend: seg.tr,
                startTime: vD[0].time, endTime: vD[vD.length-1].time,
                isLast: isLast,
            });
        }

        // â”€â”€ Liquidity lines â”€â”€
        if (ind.liquidity) {
            const iS = INT_SEC[curTF];
            for (const liq of ind.liquidity) {
                const ld = [];
                for (let j = 0; j <= 5; j++) ld.push({ time: liq.time + j * iS, value: liq.price });
                const ls = chart.addLineSeries({
                    color: liq.type === "support" ? 'rgba(23,214,166,0.4)' : 'rgba(211,48,102,0.4)',
                    lineWidth: 1, lineStyle: 0,
                    lastValueVisible: false, priceLineVisible: false, crosshairMarkerVisible: false,
                });
                ls.setData(ld);
                extra.push(ls);
            }
        }

        // â”€â”€ Float Vol Delta removed â”€â”€
    }

    function r3(v) { return Math.round(v * 1000) / 1000; }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // COUNTDOWN TIMER
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const countdownEl = document.getElementById('countdown');
    // Shared up/down state for price label + countdown color sync
    let lastCandleUp = true;

    function updCandleDirection() {
        const cur = liveC || (hist.length ? hist[hist.length-1] : null);
        if (!cur) return;
        lastCandleUp = cur.close >= cur.open;
    }

    function updCountdown() {
        const cur = liveC || (hist.length ? hist[hist.length-1] : null);
        if (!cur || !cSeries) { countdownEl.classList.remove('visible'); return; }
        const endTime = cur.time + curSec;
        const remain = endTime - Math.floor(Date.now() / 1000);
        if (remain <= 0 || remain > curSec) { countdownEl.classList.remove('visible'); return; }
        const mm = Math.floor(remain / 60);
        const ss = remain % 60;
        countdownEl.textContent = String(mm).padStart(2,'0') + ':' + String(ss).padStart(2,'0');
        // Position right below the price label on Y axis
        const py = cSeries.priceToCoordinate(cur.close);
        if (py === null || isNaN(py)) { countdownEl.classList.remove('visible'); return; }
        countdownEl.style.top = (py + 9) + 'px';
        // Background same hue as price label but lighter
        countdownEl.style.background = lastCandleUp ? 'rgba(8,153,129,0.55)' : 'rgba(242,54,69,0.55)';
        countdownEl.style.color = '#fff';
        // Center countdown within price scale area
        const psW = chart.priceScale('right').width();
        const cdW = countdownEl.offsetWidth;
        const chartW = chartEl.clientWidth;
        countdownEl.style.left = (chartW - psW + (psW - cdW) / 2 - 5.5) + 'px';
        countdownEl.classList.add('visible');
    }
    setInterval(updCountdown, 1000);

    // Update price line color based on candle direction
    function updPriceLineColor() {
        if (!cSeries) return;
        cSeries.applyOptions({ priceLineColor: lastCandleUp ? C_UP : C_DN });
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // WEBSOCKET
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function connectWS() {
        if (ws) { ws.close(); ws = null; }
        ws = new WebSocket(`${WS_URL}/ws/price`);
        ws.onopen = () => {
            console.log("ğŸ”Œ WS connected");
            document.getElementById('statusDot').className = 'status-dot-live';
        };
        ws.onmessage = e => {
            try { const m = JSON.parse(e.data); if (m.type === "tick") onTick(m.price, m.latency); } catch(e) {}
        };
        ws.onclose = () => {
            document.getElementById('statusDot').className = 'status-dot-live error';
            setTimeout(connectWS, 3000);
        };
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TICK
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function onTick(price, lat) {
        const now = Math.floor(Date.now() / 1000);
        ticks++;
        if (!sOpen) sOpen = price;
        if (price > sHi) sHi = price;
        if (price < sLo) sLo = price;

        const ct = Math.floor(now / curSec) * curSec;
        if (liveC && liveC.time !== ct) pushH();
        if (!liveC || liveC.time !== ct) {
            liveC = { time: ct, open: price, high: price, low: price, close: price };
        } else {
            liveC.close = price;
            if (price > liveC.high) liveC.high = price;
            if (price < liveC.low) liveC.low = price;
        }

        rTick(price, ct);
        updCandleDirection();
        updPriceLineColor();
        updCountdown();
        if (sigCurrent) sigUpdatePos();
        updUI(price, lat);
        prevP = price;
    }

    function pushH() {
        if (!liveC) return;
        const i = hist.findIndex(c => c.time === liveC.time);
        if (i >= 0) hist[i] = { ...liveC };
        else if (liveC.time > lastHT) { hist.push({ ...liveC }); lastHT = liveC.time; }
        liveC = null;
    }

    function rTick(price, ct) {
        if (!cSeries) return;
        if (hist.length) {
            const last = hist[hist.length - 1];
            if (last.time === ct) {
                last.close = price;
                if (price > last.high) last.high = price;
                if (price < last.low) last.low = price;
                if (ready) cSeries.update(last);
                else { cSeries.setData(hist); ready = true; }
                smartScroll(); updCC(); return;
            }
        }
        if (liveC) {
            if (!ready) {
                const a = [...hist];
                if (liveC.time > lastHT) a.push(liveC);
                cSeries.setData(a); ready = true;
            } else {
                cSeries.update(liveC);
            }
            updCC();
        }
        smartScroll();
    }

    function renderAll(initial) {
        if (!cSeries) return;
        let a = [...hist];
        if (liveC && liveC.time > lastHT) a.push(liveC);
        cSeries.setData(a);
        if (initial && a.length > 0) {
            // Show last ~120 candles, with the last candle in center-right
            const barsToShow = 120;
            const from = Math.max(0, a.length - barsToShow);
            chart.timeScale().setVisibleLogicalRange({ from: from, to: a.length + 15 });
        } else {
            smartScroll();
        }
        ready = true;
        updCC();
    }

    function updCC() {
        let c = hist.length;
        if (liveC && liveC.time > lastHT) c++;
        document.getElementById('statCandles').textContent = c;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AUTO REFRESH
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let rTimer = null;
    function startRefresh() {
        if (rTimer) clearInterval(rTimer);
        rTimer = setInterval(async () => {
            try {
                const r = await fetch(`${SERVER}/api/history?interval=${curTF}&bars=10`);
                const d = await r.json();
                if (!d.candles) return;
                let u = 0;
                for (const nc of d.candles) {
                    const i = hist.findIndex(c => c.time === nc.time);
                    if (i >= 0) { hist[i] = nc; u++; }
                    else if (nc.time > lastHT) { hist.push(nc); lastHT = nc.time; u++; }
                }
                if (u > 0) { hist.sort((a,b) => a.time - b.time); renderAll(); }
            } catch(e) {}
        }, 60000);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // UI UPDATE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function updUI(price, lat) {
        const el = document.getElementById('livePrice');
        el.textContent = price.toFixed(2);
        if (prevP !== null) {
            el.classList.remove('up', 'down');
            if (price > prevP) el.classList.add('up');
            else if (price < prevP) el.classList.add('down');
            setTimeout(() => el.classList.remove('up', 'down'), 600);
        }
        if (sOpen !== null) {
            const chg = price - sOpen;
            const ce = document.getElementById('priceChange');
            ce.textContent = (chg >= 0 ? '+' : '') + chg.toFixed(2);
            ce.className = 'price-change ' + (chg >= 0 ? 'up' : 'down');
        }
        const d = new Date();
        document.getElementById('updateTime').textContent =
            [d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds()].map(v => String(v).padStart(2,'0')).join(':');
        document.getElementById('tickCount').textContent = ticks;
        document.getElementById('statOpen').textContent = sOpen ? sOpen.toFixed(2) : '---';
        document.getElementById('statHigh').textContent = sHi > 0 ? sHi.toFixed(2) : '---';
        document.getElementById('statLow').textContent = sLo < Infinity ? sLo.toFixed(2) : '---';
        document.getElementById('statSpread').textContent = (sHi > 0 && sLo < Infinity) ? (sHi - sLo).toFixed(2) : '---';
        if (lat > 0) document.getElementById('statLatency').textContent = lat + 'ms';
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SIGNAL FROM data.json
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const sigLabelEl = document.getElementById('signalLabel');
    const sigTextEl = document.getElementById('sigText');
    const sigStatusEl = document.getElementById('sigStatus');
    let sigEntryLine = null;   // LineSeries for entry price line
    let sigCurrent = null;     // current signal data cache
    let sigTimestamp = null;    // track signal changes
    let sigEntryTime = null;   // unix timestamp of signal start
    let sigLastEndT = 0;       // last end time used in line data (avoid unnecessary updates)

    function sigStatusInfo(status) {
        // Map data.json status â†’ display text + CSS class
        switch(status) {
            case 'pending':  return { text:'WAITING', cls:'waiting' };
            case 'running':  return { text:'RUNNING', cls:'running' };
            case 'tp1_hit':  return { text:'âœ“ TP1', cls:'tp' };
            case 'tp2_hit':  return { text:'âœ“ TP2', cls:'tp' };
            case 'tp3_hit':  return { text:'âœ“ TP3', cls:'tp' };
            case 'sl_hit':   return { text:'âœ— SL', cls:'sl' };
            case 'exit':     return { text:'EXIT', cls:'waiting' };
            default:         return { text:status?.toUpperCase()||'--', cls:'waiting' };
        }
    }

    function sigParseTime(ts) {
        // Parse "2026-02-05 22:45:38" (GMT+7) â†’ unix timestamp (UTC)
        if (!ts) return null;
        const m = ts.match(/(\d{4})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2}):(\d{2})/);
        if (!m) return null;
        const d = new Date(Date.UTC(+m[1], +m[2]-1, +m[3], +m[4]-7, +m[5], +m[6]));
        return Math.floor(d.getTime() / 1000);
    }

    function sigRemove() {
        if (sigEntryLine) {
            try { chart.removeSeries(sigEntryLine); } catch(e) {}
            sigEntryLine = null;
        }
        sigLabelEl.classList.remove('visible');
        sigCurrent = null;
        sigTimestamp = null;
        sigEntryTime = null;
        sigLastEndT = 0;
    }

    function sigBuildLineData(sig) {
        // Build line data from signal time to current candle time
        const startT = sigEntryTime;
        if (!startT) return [];
        const iSec = INT_SEC[curTF];
        // Snap start to candle interval
        const snapStart = Math.floor(startT / iSec) * iSec;
        // End at current time (latest candle or now)
        const now = Math.floor(Date.now() / 1000);
        const snapEnd = Math.floor(now / iSec) * iSec;
        const pts = [];
        // Extend line far into the future so it reaches the right edge of the chart
        for (let t = snapStart; t <= snapEnd + iSec * 100; t += iSec) {
            pts.push({ time: t, value: sig.entry });
        }
        sigLastEndT = snapEnd;
        return pts;
    }

    function sigDraw(sig) {
        if (!cSeries || !sig || !sig.entry) { sigRemove(); return; }

        const isNew = sig.timestamp !== sigTimestamp;
        sigTimestamp = sig.timestamp;
        sigCurrent = sig;

        if (isNew) {
            // Save current view position before modifying series
            const savedRange = (scrollM === 'pin') ? chart.timeScale().getVisibleLogicalRange() : null;

            // Remove old line series
            if (sigEntryLine) { try { chart.removeSeries(sigEntryLine); } catch(e) {} }
            sigEntryTime = sigParseTime(sig.timestamp);
            // Create LineSeries for entry
            sigEntryLine = chart.addLineSeries({
                color: '#fbbf24',
                lineWidth: 2,
                lineStyle: LightweightCharts.LineStyle.Dashed,
                lastValueVisible: true,
                priceLineVisible: false,
                crosshairMarkerVisible: false,
                title: '',
            });
            sigEntryLine.setData(sigBuildLineData(sig));

            // Restore view position in Pin mode
            if (savedRange) {
                chart.timeScale().setVisibleLogicalRange(savedRange);
            }
        } else {
            // Only update line data when a new candle interval starts
            const iSec = INT_SEC[curTF];
            const nowSnap = Math.floor(Date.now() / 1000 / iSec) * iSec;
            if (sigEntryLine && nowSnap > sigLastEndT) {
                sigEntryLine.setData(sigBuildLineData(sig));
            }
        }

        // Update label text
        const sigName = sig.signal || 'SIGNAL';
        sigTextEl.textContent = sigName + ' ' + sig.entry;

        // Update status badge
        const si = sigStatusInfo(sig.status);
        sigStatusEl.textContent = si.text;
        sigStatusEl.className = 'sig-status ' + si.cls;

        // Position label above entry line, centered on chart
        sigUpdatePos();
    }

    function sigUpdatePos() {
        if (!sigCurrent || !cSeries || !sigEntryTime) { sigLabelEl.classList.remove('visible'); return; }
        const py = cSeries.priceToCoordinate(sigCurrent.entry);
        if (py === null || isNaN(py)) { sigLabelEl.classList.remove('visible'); return; }
        // Position above entry line
        sigLabelEl.style.top = (py - 22) + 'px';
        // X position: at signal candle, or pinned to left edge if signal is off-screen left
        const iSec = INT_SEC[curTF];
        const snapStart = Math.floor(sigEntryTime / iSec) * iSec;
        const px = chart.timeScale().timeToCoordinate(snapStart);
        if (px !== null && !isNaN(px) && px >= 0) {
            // Signal candle is visible â€” position label at that candle
            sigLabelEl.style.left = px + 'px';
        } else {
            // Signal candle is off-screen left â€” pin label to left edge
            sigLabelEl.style.left = '8px';
        }
        sigLabelEl.classList.add('visible');
    }

    // Poll signal data every 2 seconds
    function fetchSignal() {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', SERVER + '/api/signal?' + Date.now(), true);
        xhr.onreadystatechange = function() {
            if (xhr.readyState === 4 && (xhr.status === 200 || xhr.status === 0)) {
                try {
                    const data = JSON.parse(xhr.responseText);
                    if (data && data.current_signal) {
                        sigDraw(data.current_signal);
                    } else {
                        sigRemove();
                    }
                } catch(e) { /* ignore parse errors */ }
            }
        };
        xhr.send();
    }
    setInterval(fetchSignal, 2000);

    // Also reposition signal label when chart scrolls or resizes
    chart.timeScale().subscribeVisibleLogicalRangeChange(() => { if (sigCurrent) sigUpdatePos(); });

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TF BUTTONS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    document.querySelectorAll('.tf-btn').forEach(btn => {
        btn.addEventListener('click', async () => {
            document.querySelectorAll('.tf-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            curTF = btn.dataset.tf;
            curSec = INT_SEC[curTF];
            liveC = null; ready = false; saved = null;
            sigRemove();
            clrExtra();
            setScroll('auto');
            await loadHist(curTF);
            fetchSignal();
            startRefresh();
        });
    });

    new ResizeObserver(entries => {
        for (const e of entries) chart.applyOptions({ width: e.contentRect.width, height: e.contentRect.height });
    }).observe(chartEl);

    chart.timeScale().subscribeVisibleTimeRangeChange(() => {});

    (async () => {
        console.log("ğŸš€ XAU/USD v14 â€” candles on top, single price label, no price line");
        curSec = INT_SEC[curTF];
        await loadHist(curTF);
        connectWS();
        fetchSignal();
        startRefresh();
    })();
})();
</script>
</body>
</html>